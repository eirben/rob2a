#pragma config(Sensor, in1,    clawAngle,      sensorPotentiometer)
#pragma config(Sensor, in3,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in4,    midLine,        sensorLineFollower)
#pragma config(Sensor, in5,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in7,    turnAngle,      sensorGyro)
#pragma config(Sensor, in8,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  bumber,         sensorTouch)
#pragma config(Sensor, dgtl2,  clawStop,       sensorTouch)
#pragma config(Sensor, dgtl4,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl10, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, encoder, encoderPort, dgtl7, 1000)
#pragma config(Motor,  port6,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           verticleClawMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorServoContinuousRotation, openLoop,reversed, encoder, encoderPort, dgtl10, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Moving Forward -                                         *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs your robot to move forward at full power for three seconds.  There is a    *|
|*  two second pause at the beginning of the program.                                                 *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*  			Task display displays battery life on the main bettry and updates every 100 miliseconds.		*|
|*				distance of wheel turn = 5.5*2*PI = 34.56		 																								*|
|*				turn90 turns right(True) or left(False) for 90 degrees																			*|
|*				stopMotor and resetEncoder are utility functions to make things easier											*|
|*				this is version 011 or 3 of Robert Robot here he will go forward half a meter and turn			*|
|*				in a path																																										*|
|*				previous versions are version 001 and 010																										*|
|*				you'll find all versions here:																															*|
|*				https://github.com/kartoflu-supa/rob2a																											*|
|*				in the motors & sensors section you will see the name and port of the motors and Sensors		*|
|*				taskmain:																																										*|
|*					1)Starts by going forward 0.5m																														*|
|*					2)then it enters a for loop of turning 90 degrees after array turns then goes forward 		*|
|*						another 0.5m																																						*|
|*					3)once the loop has counted from 0 to 13 the machine and code stops												*|
|*																																																		*|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor Port 2        rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor Port 3        leftMotor           VEX 3-wire module     Left side motor   								*|
|*		Digital port 1      touchSensor1        VEX 3-wire module     Front bumber sensor								*|
|*		Digital port 2      touchSensor2        VEX 3-wire module     Claw stop sensor									*|
|*		Analog port 8       lightSensor         VEX 3-wire module     Ambient light sensor							*|
|*		Digital port 4      sonarSensor         VEX 3-wire module     Front distance sensor							*|
|*		Digital port 5      sonarSensor  				VEX 3-wire module     Front distance sensor							*|
|*		Digital port 7-8    rightEncoder 				VEX 3-wire module			Left side encoder									*|
|*		Digital port 10-11  leftEncoder				  VEX 3-wire module			Right side encoder								*|
|*		Analog port 1       poteniometer				VEX 3-wire module			Claw poteniometer									*|
\*----------------------------------------------------------------------------------------------------*/
const int FULL_FORWARD = 127;
const int BASE_DIST = 518;
const float BASE_DEG = 36/11;
bool b_f = true;

bool turns[14] = {true, false, false, true, true, false, true, true ,false, true, true, false, true, true};
task display(){
		bLCDBacklight = true;									// Turn on LCD Backlight
	string mainBattery, backupBattery;

	while(true)
	{
		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c",);
		displayNextLCDString(mainBattery);

		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);

		wait1Msec(100);
	}
}
task control(){
	while(vexRT[Btn8U] == 0 && SensorValue[bumber] == 0){}
	while(1 == 1){
		hogCPU();
		motor[rightMotor]  = vexRT[Ch2];  // (y + x)/2
		motor[leftMotor] = vexRT[Ch3];  // (y + x)/2

// Raise, lower or do not move arm
		if(vexRT[Btn5D] == 1)       	//If button 5U is pressed...
		{
			motor[verticleClawMotor] = 127;    	//...raise the arm.
		}
		else if(vexRT[Btn5U] == 1)  	//Else, if button 5D is pressed...
		{
			motor[verticleClawMotor] = -127;   	//...lower the arm.
		}
		else                      		//Else (neither button is pressed)...
		{
			motor[verticleClawMotor] = 0;      	//...stop the arm.
		}

// Open, close or do not move claw
		if(vexRT[Btn6U] == 1)       	//If Button 6U is pressed...
		{
			motor[clawMotor] = 127;  		//...close the gripper.
		}
		else if(vexRT[Btn6D] == 1)  	//Else, if button 6D is pressed...
		{
			motor[clawMotor] = -127; 		//...open the gripper.
		}
		else                      		//Else (neither button is pressed)...
		{
			motor[clawMotor] = 0;    		//...stop the gripper.
		}
		if (vexRT[Btn8D] > 0){
			wait1Msec(500);
			releaseCPU();
	 		StartTask(display);
	 		StopTask(control);
	 		StartTask(control);
		}
	}
}
void stopMotor() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
void resetEncoder(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void turn90(bool l_r) {
	int turn_num = BASE_DEG*80;
	resetEncoder();
	if (l_r) {
		while(abs(SensorValue[leftEncoder]) < turn_num || abs(SensorValue[rightEncoder]) < turn_num){

		if (abs(SensorValue[leftEncoder]) < turn_num){motor[leftMotor] = FULL_FORWARD;}
		if (abs(SensorValue[rightEncoder]) < turn_num){motor[rightMotor] = FULL_FORWARD * -1;}
	}}
	else {
		while(abs(SensorValue[leftEncoder]) < turn_num || abs(SensorValue[rightEncoder]) < turn_num){
		if (abs(SensorValue[leftEncoder]) < turn_num){motor[leftMotor] = FULL_FORWARD * -1;}
		if (abs(SensorValue[rightEncoder])< turn_num){motor[rightMotor] = FULL_FORWARD;}
	}}
	stopMotor();
}
void drive(int driveDistance, bool b_f){
	int dir = (b_f)? (1):(-1);
		resetEncoder();
		while (SensorValue[leftEncoder] < driveDistance && SensorValue[rightEncoder] < driveDistance){
		if (SensorValue[leftEncoder] < SensorValue[rightEncoder]){
				motor[leftMotor] = FULL_FORWARD*dir;
				motor[rightMotor] = (FULL_FORWARD-13)*dir;
		}
		if (SensorValue[leftEncoder] > SensorValue[rightEncoder]){
				motor[leftMotor] = (FULL_FORWARD-13)*dir;
				motor[rightMotor] = FULL_FORWARD*dir;
		}
		if (SensorValue[leftEncoder] == SensorValue[rightEncoder]){
				motor[leftMotor] = FULL_FORWARD*dir;
				motor[rightMotor] = FULL_FORWARD*dir;
	 }
	}
	stopMotor();
}

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	StartTask(display);
	StartTask(control);
	wait1Msec(1000);
	drive(BASE_DIST,true);
	for(int i=0;i<14;i++){
		wait1Msec(1000);
		turn90(turns[i]);
		wait1Msec(1000);
		drive(BASE_DIST,true);
		}
	stopMotor();
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
